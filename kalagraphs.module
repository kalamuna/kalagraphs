<?php

/**
 * @file
 * Contains kalagraphs.module.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Render\Element;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Component\Utility\Html;

// @todo
// - Don't hardcode these here but rather use an info hook, yaml file, managed
//   configuration, State API, etc. Or grab them directly from the styleguide
//   component's JSON files!
// - Make sure the "help" text gets translated.
const KALAGRAPHS_TYPES = [
  'hidden' => [
    'title' => '_Hidden',
    'function' => '_kalagraphs_render_hidden',
    'fields' => [],
    'help' => 'Temporarily hide this component without losing its data.',
  ],
  'tout__mega' => [
    'title' => 'Megatout',
    'template' => 'tout--mega',
    'path' => '@molecules',
    'fields' => [
      'title',
      'text',
      'image',
      'links',
    ],
  ],
  'tout__cta' => [
    'title' => 'CTA Tout',
    'template' => 'tout--cta',
    'path' => '@molecules',
    'fields' => [
      'title',
      'text',
      'image',
      'links',
    ],
  ],
  'hero' => [
    'title' => 'Hero',
    'template' => 'hero',
    'path' => '@molecules',
    'fields' => [
      'title',
      'text',
      'image',
      'links',
    ],
    'bundles' => ['kalagraphs_component'],
  ],
  'card__program' => [
    'title' => 'Program Card',
    'template' => 'card--program',
    'path' => '@molecules',
    'fields' => [
      'title',
      'text',
      'image',
      'links',
    ],
  ],
  'layout__4_8' => [
    'title' => 'Layout: Sidebar w/Main',
    'template' => 'layout--4-8',
    'path' => '@layouts',
    'fields' => [
      'subcomponents',
    ],
    'bundles' => ['kalagraphs_component'],
    'help' => 'Now add two "layout column" components.',
  ],
  'layout__column' => [
    'title' => 'Layout column',
    'fields' => [
      'subcomponents',
    ],
    'bundles' => ['kalagraphs_subcomponent'],
    'help' => 'Add components to this layout column.',
  ],
];

/**
 * Theme callback to render the "hidden" component type.
 */
function _kalagraphs_render_hidden() {
  // Don't render anything.
}

/**
 * Implements hook_help().
 */
function kalagraphs_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the kalagraphs module.
    case 'help.page.kalagraphs':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Kalagraphs provides a flexible Paragraph type called &quot;Component&quot; that allows editors to choose with which Twig template the component will render.') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_preprocess().
 */
function kalagraphs_preprocess(&$vars, $hook, $info) {
  if ($hook == 'paragraph') {
    // Only run on the special Paragraphs bundles.
    $paragraph = &$vars['elements']['#paragraph'];
    if (substr($paragraph->bundle(), 0, 12) !== 'kalagraphs__') {
      _kalagraphs_populate_fields($vars);
    }
  }
}

/**
 * A custom preprocess callback specified in kalagraphs_theme().
 *
 * Populates template data with field items, using template-friendly variable
 * names.
 *
 * Note that despite what the documentation says about "base hook" (see
 * hook_theme()), the original theme hook's preprocess functions aren't getting
 * called (i.e., hook_preprocess_paragraph()), perhaps because we are using
 * hook_theme_suggestions_alter() to invoke our custom theme hook rather than
 * doing it directly. We get around this limitation by calling this
 * preprocessor manually in an implementation of the generic hook.
 *
 * @see kalagraphs_theme()
 * @see hook_preprocess_HOOK()
 */
function _kalagraphs_populate_fields(&$vars) {
  $elements = &$vars['elements'];
  $paragraph = $elements['#paragraph'];

  // Add a flag to indicate it is rendering in a Drupal context.
  // @todo This doesn't cover non-Paragraph theme hooks, e.g., atom components
  // used for some fields.
  $vars['drupal'] = TRUE;

  // Map field items to template variables.
  foreach (Element::children($elements) as $field) {
    $element = &$elements[$field];
    foreach (Element::children($element) as $item) {
      // Make a template-friendly variable name by stripping "field_kalagraphs_"
      // from the front.
      $name = substr($field, 17);
      $vars[$name][] = $element[$item];
    }
  }

  // Provide a unique id attribute for the element that may or may not get used.
  $vars['id'] = Html::getUniqueId("kalagraphs-component-{$paragraph->field_kalagraphs_type->value}");
}

/**
 * Implements hook_theme().
 */
function kalagraphs_theme() {
  // First, manually create some theme hooks for certain atoms.
  //
  // @todo Don't hardcode these here but rather use an info hook, yaml file,
  // managed configuration, State API, etc. Or grab them directly from the
  // styleguide component's JSON files!
  //
  // @see \Drupal\kalagraphs\Plugin\Field\FieldFormatter\KalagraphsLinkFormatter
  // @see \Drupal\kalagraphs\Plugin\Field\FieldFormatter\KalagraphsImageFormatter
  $items['kalastatic__link'] = [
    'template' => 'link',
    'path' => '@atoms/link',
    'variables' => [
      'url' => '',
      'text' => '',
      'class' => '',
    ],
  ];
  $items['kalastatic__link__icon'] = [
    'template' => 'link--icon',
    'path' => '@atoms/link--icon',
    'variables' => [
      'url' => '',
      'text' => '',
      'class' => '',
    ],
  ];
  $items['kalastatic__image'] = [
    'template' => 'image',
    'path' => '@atoms/image',
    'variables' => [
      'src' => '',
      'alt' => '',
      'title' => '',
      'class' => '',
      'width' => '',
      'height' => '',
    ],
  ];

  // Add fallback templates that cure divitus.
  $items['kalagraphs_default'] = [
    'base hook' => 'paragraph',
  ];
  $items['kalagraphs_field'] = [
    'base hook' => 'field',
  ];

  // Next, create theme hooks for each Kalagraphs component type. These don't
  // usually get invoked directly but rather via hook_theme_suggestions_alter().
  //
  // @todo Replace reference to hard-coded component types with a function that
  // pulls them from another source: other modules, themes, managed config,
  // State API, yaml files, styleguide components' JSON data, etc.
  foreach (KALAGRAPHS_TYPES as $component => $info) {
    $name = "kalagraphs__$component";

    // Some get rendered by functions.
    if (!empty($info['function'])) {
      $items[$name] = ['function' => $info['function']];
    }

    // Others use templates.
    elseif (!empty($info['template'])) {
      $items[$name] = [
        'template' => $info['template'],
        'path' => "{$info['path']}/{$info['template']}",
        'base hook' => 'paragraph',
      ];
    }
  }

  return $items;
}

/**
 * Implements hook_theme_suggestions_HOOK_alter() for paragraph().
 *
 * Tells the Kalagraphs component to use the proper theme hook.
 */
function kalagraphs_theme_suggestions_paragraph_alter(array &$suggestions, array $vars) {
  $paragraph = $vars['elements']['#paragraph'];
  if (substr($paragraph->bundle(), 0, 11) === 'kalagraphs_' && 'default' === $vars['elements']['#view_mode']) {
    $suggestions[] = 'kalagraphs_default';
    $suggestions[] = "kalagraphs__{$paragraph->field_kalagraphs_type->value}";
  }
}

/**
 * Implements hook_theme_suggestions_HOOK_alter() for field().
 *
 * Renders Kalagraphs fields with a minimal template. Note that this only gets
 * invoked when a Kalagraphs type doesn't map to a custom template or render
 * function and therefore gets displayed through the regular field pipeline.
 */
function kalagraphs_theme_suggestions_field_alter(array &$suggestions, array $vars) {
  if (strpos($vars['element']['#field_name'], 'field_kalagraphs_') === 0 && 'default' === $vars['element']['#view_mode']) {
    $suggestions[] = 'kalagraphs_field';
  }
}

/**
 * Implements callback_allowed_values_function().
 *
 * Returns the allowed values for the "Kalagraphs Type" options list field.
 */
function _kalagraphs_options(FieldStorageDefinitionInterface $definition, FieldableEntityInterface $entity = NULL, &$cacheable = TRUE) {
  // Don't let options_allowed_values() cache the values, because we need to
  // vary them by parent entity.
  $cacheable = FALSE;
  $options = [];
  foreach (KALAGRAPHS_TYPES as $type => $info) {
    // @todo We _really_ can't get access to the name of the paragraphs field on
    // the parent entity here? Then we wouldn't have to bother with having a
    // separate bundle for "sub-components."
    if (empty($info['bundles']) || in_array($entity->bundle(), $info['bundles'])) {
      $options[$type] = $info['title'];
    }
  }
  // @todo Manually add "hidden" option here (and remove from main list).
  asort($options);
  return $options;
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter() for paragraphs().
 */
function kalagraphs_field_widget_paragraphs_form_alter(&$element, FormStateInterface $form_state, $context) {

  // Only run once a Paragraph form has been loaded.
  $subform = &$element['subform'];
  if (!count($fields = Element::children($subform))) {
    return;
  }

  // Use the form's #parents to determine the States API selector.
  $parents_array = $subform['#parents'];
  $first_parent = array_shift($parents_array);
  $parents = $first_parent . '[' . implode('][', $parents_array) . ']';
  $selector = ":input[name='{$parents}[field_kalagraphs_type]']";

  // Add helptext for when no component type is yet selected.
  $help = &$subform['help']['_none'];
  $help['#type'] = 'item';
  $help['#title'] = t('Choose a component type to create.');
  $help['#states']['visible'][$selector][] = ['value' => '_none'];

  // Add a null state so fields not used on any component type are still hidden.
  foreach ($fields as $field) {
    // Don't hide the "Display as" selector.
    if ('field_kalagraphs_type' !== $field) {
      $subform[$field]['#states']['visible'][$selector][] = ['value' => -1];
    }
  }

  // Add helptext and conditional states for each component type.
  foreach (KALAGRAPHS_TYPES as $type => $info) {
    $condition = ['value' => $type];

    // Add helptext for each component type.
    if (!empty($info['help'])) {
      $help = &$subform['help'][$type];
      $help['#type'] = 'item';
      $help['#title'] = $info['help'];
      $help['#states']['visible'][$selector][] = $condition;
    }

    // Only show the fields appropriate for the component type.
    foreach ($info['fields'] as $field) {
      if (isset($subform["field_kalagraphs_$field"])) {
        $subform["field_kalagraphs_$field"]['#states']['visible'][$selector][] = $condition;
      }
    }
  }
}
