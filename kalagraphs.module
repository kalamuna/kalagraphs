<?php

/**
 * @file
 * Contains kalagraphs.module.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Render\Element;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Component\Utility\Html;

// @todo
// - Don't hardcode these here but rather use an info hook, yaml file, managed
//   configuration, State API, etc. Or grab them directly from the styleguide
//   component's JSON files!
// - Make sure the "help" text gets translated.
const KALAGRAPHS_TYPES = [
  'tout__mega' => [
    'title' => 'Megatout',
    'template' => 'tout--mega',
    'path' => '@kalagraphs/molecules',
    'fields' => [
      'title',
      'text',
      'image',
      'links',
    ],
    'bundles' => ['kalagraphs_component'],
  ],
  'tout__cta' => [
    'title' => 'CTA Tout',
    'template' => 'tout--cta',
    'path' => '@kalagraphs/molecules',
    'fields' => [
      'title',
      'text',
      'image',
      'links',
    ],
    'bundles' => ['kalagraphs_component'],
  ],
  'hidden' => [
    'title' => '_Hidden',
    'fields' => [],
    'bundles' => ['kalagraphs_component', 'kalagraphs_subcomponent'],
    'help' => 'Temporarily hide this component without losing its data.',
  ],
];

/**
 * Theme callback to render the "hidden" component type.
 */
function _kalagraphs_render_hidden() {
  // Don't render anything.
}

/**
 * Implements hook_help().
 */
function kalagraphs_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the kalagraphs module.
    case 'help.page.kalagraphs':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Kalagraphs provides a flexible Paragraph type called &quot;Component&quot; that allows editors to choose with which Twig template the component will render.') . '</p>';
      return $output;

    default:
  }
}

/**
 * A custom preprocess callback specified in kalagraphs_theme().
 *
 * Populates template data with field items, using template-friendly variable
 * names.
 *
 * Note that despite what the documentation says about "base hook" (see
 * hook_theme()), the original theme hook's preprocess functions aren't getting
 * called (i.e., hook_preprocess_paragraph()), perhaps because we are using
 * hook_theme_suggestions_alter() to invoke our custom theme hook rather than
 * doing it directly. We get around this limitation by specifying this
 * preprocessor manually in the theme hook definition.
 *
 * @see kalagraphs_theme()
 * @see hook_preprocess_HOOK()
 */
function _kalagraphs_populate_fields(&$vars) {

  // Only run on the special Paragraphs bundles.
  $elements = &$vars['elements'];
  $paragraph = $elements['#paragraph'];
  if (substr($paragraph->bundle(), 0, 11) !== 'kalagraphs_') {
    return;
  }

  // Add a flag to indicate it is rendering in a Drupal context.
  // @todo This doesn't cover non-Paragraph theme hooks, e.g., atom components
  // used for some fields.
  $vars['drupal'] = TRUE;

  // Map field items to template variables.
  foreach (Element::children($elements) as $field) {
    $element = &$elements[$field];
    foreach (Element::children($element) as $item) {
      // Make a template-friendly variable name by stripping "field_kalagraphs_"
      // from the front.
      $name = substr($field, 17);
      $vars[$name][] = $element[$item];
    }
  }

  // Provide a unique id attribute for the element that may or may not get used.
  $vars['id'] = Html::getUniqueId("kalagraphs-component-{$paragraph->field_kalagraphs_type->value}");
}

/**
 * Implements hook_theme().
 */
function kalagraphs_theme() {

  // First, manually create some theme hooks for certain atoms.
  //
  // @todo Don't hardcode these here but rather use an info hook, yaml file,
  // managed configuration, State API, etc. Or grab them directly from the
  // styleguide component's JSON files!
  //
  // @see \Drupal\kalagraphs\Plugin\Field\FieldFormatter\KalagraphsLinkFormatter
  // @see \Drupal\kalagraphs\Plugin\Field\FieldFormatter\KalagraphsImageFormatter
  $items['kalagraphs_link'] = [
    'template' => 'link',
    'path' => '@atoms/link',
    'variables' => [
      'url' => '#',
      'text' => '',
      'class' => '',
    ],
  ];
  $items['kalagraphs_link__icon'] = [
    'template' => 'link--icon',
    'path' => '@atoms/link--icon',
    'variables' => [
      'url' => '#',
      'text' => '',
      'class' => '',
    ],
  ];
  $items['kalagraphs_image'] = [
    'template' => 'image',
    'path' => '@atoms/image',
    'variables' => [
      'src' => '',
      'alt' => '',
      'title' => '',
      'class' => '',
    ],
  ];

  // Next, create theme hooks for each Kalagraphs component type. These don't
  // usually get invoked directly but rather via hook_theme_suggestions_alter().
  //
  // @todo Replace reference to hard-coded component types with a function that
  // pulls them from another source: other modules, themes, managed config,
  // State API, yaml files, styleguide components' JSON data, etc.
  foreach (KALAGRAPHS_TYPES as $component => $info) {
    $item = &$items["kalagraphs_$component"];

    // Create a special theme hook for the "hidden" component type.
    if ('hidden' === $component) {
      $item = ['function' => '_kalagraphs_render_hidden'];
      continue;
    }

    $item = [
      'template' => $info['template'],
      'path' => "{$info['path']}/{$info['template']}",
      // See _kalagraphs_populate_fields() for explanation of this necessity.
      'preprocess functions' => [
        '_kalagraphs_populate_fields',
        "template_preprocess_kalagraphs_$component",
      ],
    ];
  }

  return $items;
}

/**
 * Implements hook_theme_suggestions_HOOK_alter() for paragraph().
 *
 * Tells the Kalagraphs component to use the proper theme hook.
 */
function kalagraphs_theme_suggestions_paragraph_alter(array &$suggestions, array $vars) {
  $paragraph = $vars['elements']['#paragraph'];
  if (substr($paragraph->bundle(), 0, 11) === 'kalagraphs_'  && 'default' === $vars['elements']['#view_mode']) {
    $suggestions[] = "kalagraphs_{$paragraph->field_kalagraphs_type->value}";
  }
}

/**
 * Preprocess 
 */
function template_preprocess_kalagraphs_tout__cta(&$vars) {
  if (!empty($vars['links'])) {
    foreach ($vars['links'] as &$link) {
      $link['#theme'] = 'kalagraphs_link__icon';
      $link['#class'] = 'link--icon';
    }
  }
}

/**
 * Implements callback_allowed_values_function().
 *
 * Returns the allowed values for the "Kalagraphs Type" options list field.
 */
function _kalagraphs_options(FieldStorageDefinitionInterface $definition, FieldableEntityInterface $entity = NULL, &$cacheable = TRUE) {
  // Don't let options_allowed_values() cache the values, because we need to
  // vary them by parent entity.
  $cacheable = FALSE;
  $options = [];
  foreach (KALAGRAPHS_TYPES as $type => $info) {
    if (in_array($entity->bundle(), $info['bundles'])) {
      $options[$type] = $info['title'];
    }
  }
  asort($options);
  return $options;
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter() for paragraphs().
 */
function kalagraphs_field_widget_paragraphs_form_alter(&$element, FormStateInterface $form_state, $context) {

  // Only run once a Paragraph form has been loaded.
  $subform = &$element['subform'];
  if (!count($fields = Element::children($subform))) {
    return;
  }

  // Use the form's #parents to determine the States API selector.
  $parents_array = $subform['#parents'];
  $first_parent = array_shift($parents_array);
  $parents = $first_parent . '[' . implode('][', $parents_array) . ']';
  $selector = ":input[name='{$parents}[field_kalagraphs_type]']";

  // Add helptext for when no component type is yet selected.
  $help = &$subform['help']['_none'];
  $help['#type'] = 'item';
  $help['#title'] = t('Choose a component type to create.');
  $help['#states']['visible'][$selector][] = ['value' => '_none'];

  // Add a null state so fields not used on any component type are still hidden.
  foreach ($fields as $field) {
    // Don't hide the "Display as" selector.
    if ('field_kalagraphs_type' !== $field) {
      $subform[$field]['#states']['visible'][$selector][] = ['value' => -1];
    }
  }

  // Add helptext and conditional states for each component type.
  foreach (KALAGRAPHS_TYPES as $type => $info) {
    $condition = ['value' => $type];

    // Add helptext for each component type.
    $help = &$subform['help'][$type];
    $help['#type'] = 'item';
    $help['#title'] = empty($info['help'])
      ? t('<em>Add some help text here for creating "Section Header" components...</em>')
      : $info['help'];
    $help['#states']['visible'][$selector][] = $condition;

    // Only show the fields appropriate for the component type.
    foreach ($info['fields'] as $field) {
      if (isset($subform["field_kalagraphs_$field"])) {
        $subform["field_kalagraphs_$field"]['#states']['visible'][$selector][] = $condition;
      }
    }
  }
}
