<?php

/**
 * @file
 * Contains kalagraphs.module.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Render\Element;
use Drupal\Core\Render\Markup;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Component\Utility\Html;

/**
 * Implements hook_help().
 */
function kalagraphs_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.kalagraphs':
      $output = '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Kalagraphs provides a flexible Paragraph type called &quot;Component&quot; that allows editors to choose with which Twig template the component will render.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_theme().
 */
function kalagraphs_theme() {
  return [

    // Instantiate a master theme hook that calls the styleguide templates.
    'paragraph__kalagraphs_component__default' => [
      'base hook' => 'paragraph',
    ],

    // Create a theme hook to hide paragraphs.
    'kalagraphs_hidden' => [
      'function' => '_kalagraphs_render_hidden',
    ],

    // Add a field template to relieve some divitus.
    'kalagraphs_field' => [
      'base hook' => 'field',
    ],
  ];
}

/**
 * Theme callback to render the "hidden" component type.
 */
function _kalagraphs_render_hidden() {
  // Don't render anything.
}

/**
 * Preprocessor for the "paragraphs__kalagraphs_component__default" theme hook.
 *
 * Populates template data with field items, using template-friendly variable
 * names.
 */
function template_preprocess_paragraph__kalagraphs_component__default(&$vars) {

  // Provide the component's template name for inclusion by the master template.
  $paragraph = $vars['paragraph'];
  $type = $paragraph->field_kalagraphs_type->value;
  $info = KALAGRAPHS_TYPES[$type];
  if (isset($info['path'])) {
    $path = $info['path'];
    $template = isset($info['template']) ? $info['template'] : $type;
    $vars['component'] = "$path/$template/$template.html.twig";
  }

  // Add a flag to indicate it is rendering in a Drupal context.
  $vars['kalagraphs']
    = $vars['drupal']
      = TRUE;

  // Insert the author's name and "created" (aka "Authored on") date from the
  // entity to which this paragraph belongs.
  $parent = $paragraph->getParentEntity();
  $author = empty($parent) ? \Drupal::currentUser() : $parent->getOwner();
  $vars['author'] = $author->getDisplayName();
  $timestamp = empty($parent) ? time() : $parent->getCreatedTime();
  $vars['date'] = date('m/d/Y - h:i A', $timestamp);

  // Map field items to template variables.
  $elements = &$vars['elements'];
  foreach (Element::children($elements) as $field) {

    // Make a template-friendly variable name by stripping "field_kalagraphs_"
    // from the front.
    $name = substr($field, 17);
    $element = &$elements[$field];

    // @TODO This approach disables Quickedit on the fields, by stripping the
    // "items" (plural) render array and leaving only the individual "item"
    // (singular) render arrays.
    foreach (Element::children($element) as $delta) {
      $vars[$name][] = $element[$delta];
    }
  }

  // Provide a unique id attribute for the element that may or may not get used.
  $vars['id'] = Html::getUniqueId("kalagraphs-component-$type");
}

/**
 * Implements hook_theme_suggestions_HOOK_alter() for paragraph().
 *
 * Adds support for per-component-type theme hooks.
 */
function kalagraphs_theme_suggestions_paragraph_alter(array &$suggestions, array $vars) {
  $paragraph = $vars['elements']['#paragraph'];
  if ($paragraph->bundle() === 'kalagraphs_component') {
    $view_mode = $vars['elements']['#view_mode'];
    if ('default' === $view_mode) {
      $type = $paragraph->field_kalagraphs_type->value;
      $suggestions[] = empty($type) ? 'kalagraphs_hidden' : "kalagraphs_$type";
    }
  }
}

/**
 * Implements hook_theme_suggestions_HOOK_alter() for field().
 *
 * Renders Kalagraphs fields with a minimal template.
 */
function kalagraphs_theme_suggestions_field_alter(array &$suggestions, array $vars) {
  $field = $vars['element']['#field_name'];
  if (strpos($field, 'field_kalagraphs_') === 0) {
    $view_mode = $vars['element']['#view_mode'];
    if ('default' === $view_mode) {
      $suggestions[] = 'kalagraphs_field';
    }
  }
}

/**
 * Implements hook_preprocess_HOOK() for field().
 *
 * Adds helper flags to indicate context in templates.
 */
function kalagraphs_preprocess_field(array &$vars) {
  $field = $vars['element']['#field_name'];
  if (strpos($field, 'field_kalagraphs_') === 0) {
    $vars['kalagraphs']
      = $vars['drupal']
        = TRUE;
  }
}

/**
 * Implements callback_allowed_values_function().
 *
 * Returns the allowed values for the "Kalagraphs Type" options list field.
 */
function _kalagraphs_options(FieldStorageDefinitionInterface $definition, FieldableEntityInterface $entity = NULL, &$cacheable = TRUE) {
  $keys = array_keys(KALAGRAPHS_TYPES);
  $values = array_column(KALAGRAPHS_TYPES, 'title');
  $options = array_combine($keys, $values);
  asort($options);
  $options['hidden'] = t('Hidden');
  return $options;
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter() for bricks_tree_inline().
 *
 * Allows for customization of the Kalagraphs Component paragraph entity form.
 */
function kalagraphs_field_widget_bricks_tree_inline_form_alter(&$element, FormStateInterface $form_state, $context) {

  // Attach autogrow behavior to the "Text" field's textarea element.
  $element['#attached']['library'][] = 'kalagraphs/ux-tweaks';

  // Create some DRY code for adding a custom process callback to form elements.
  $add_process_callback = function (&$element) {
    if (isset($element['form']['inline_entity_form'])) {
      $ief = &$element['form']['inline_entity_form'];
      if ('kalagraphs_component' === $ief['#bundle']) {
        $ief['#process'][] = '_kalagraphs_process_form';
      }
    }
  };

  // Add conditional display logic and other sauce to new items.
  $add_process_callback($element);

  // Add conditional display logic and other sauce to existing items.
  $items = &$element['entities'];
  foreach (Element::children($items) as $delta) {
    $add_process_callback($items[$delta]);
  }
}

/**
 * Implements hook_something_something_form_alter() for something().
 *
 * Add our custom admin css to node forms.
 */
function kalagraphs_form_node_form_alter(&$form, FormStateInterface $form_state, $context) {
  // Check if our ¶ field is on this node and add our css if it is.
  if (isset($form['field_bricks'])) {
    $form['#attached']['library'][] = 'kalagraphs/admin-styles';
  }
}

/**
 * Implements callback_form_element_process() for Kalagraphs Component bricks.
 *
 * Adds conditional display and other sauce to the Paragaphs edit form.
 */
function _kalagraphs_process_form($subform, FormStateInterface &$form_state, &$complete_form) {

  // Allow modules to alter the options using hook_kalagraphs_options_alter().
  $options = &$subform['field_kalagraphs_type']['widget']['#options'];
  $widget = &$complete_form['field_bricks']['widget'];
  \Drupal::moduleHandler()->alter('kalagraphs_options', $options, $widget);

  // Use the form's #parents to determine the States API selector.
  $first_parent = reset($subform['#parents']);
  $other_parents = array_slice($subform['#parents'], 1);
  $parents_string = $first_parent . '[' . implode('][', $other_parents) . ']';
  $selector = ":input[name='{$parents_string}[field_kalagraphs_type]']";

  // Prep the help text container.
  $subform['help'] = [
    '#type' => 'container',
    '#attributes' => [
      'class' => ['kalagraphs-form-help'],
    ],
  ];

  // Create a temporary helper function to generate the help-text form element.
  /*
   * @param string $text
   *   The help text, already translated.
   * @param array $condition
   *   The State API conditions under which this help text will display.
   * @param string $type
   *   The Kalagraphs component type, or none if one is not selected.
   *
   * @return array
   *   A form element array to display the help text.
   */
  $get_helptext = function ($text, array $condition, $type) use ($selector) {
    $class = "kalagraphs-form-help--$type";
    return [
      '#type' => 'item',
      '#prefix' => "<div class='$class--wrapper'>",
      '#markup' => "<strong class='$class'>$text</strong>",
      '#suffix' => "</div>",
      '#states' => ['visible' => [$selector => [$condition]]],
    ];
  };

  // Add helptext for when no component type is yet selected.
  $help = t('Choose a component type to create.');
  $condition = ['value' => '_none'];
  $subform['help']['_none'] = $get_helptext($help, $condition, 'none');

  // Add a null state so fields not used on any component type are still hidden.
  foreach (Element::children($subform) as $field) {
    // Don't hide the "Display as" selector or the item submit buttons.
    if ('field_kalagraphs_type' !== $field && 'actions' !== $field) {
      $subform[$field]['#states']['visible'][$selector][] = ['value' => -1];
    }
  }

  // Add helptext and conditional states for each field type.
  foreach (KALAGRAPHS_TYPES as $type => $info) {
    $condition = ['value' => $type];

    // Add helptext for each component type.
    if (!empty($info['help'])) {
      $subform['help'][$type] = $get_helptext($info['help'], $condition, $type);
    }

    // Only show the fields appropriate for the component type.
    foreach ($info['fields'] as $field) {
      if (isset($subform["field_kalagraphs_$field"])) {
        $subform["field_kalagraphs_$field"]['#states']['visible'][$selector][]
          = $condition;
      }
    }
  }

  return $subform;
}

/**
 * Implements hook_entity_type_alter().
 *
 * Swaps out the Paragraph class for our own, so we can alter the entity labels.
 */
function kalagraphs_entity_type_alter(array &$entity_types) {
  $entity_types['paragraph']->setClass('Drupal\kalagraphs\Entity\Kalagraph');
}

/**
 * Prepares variables for theme_inline_entity_form_entity_table().
 *
 * Override bricks_inline_preprocess_inline_entity_form_entity_table() so we can
 * customize the tabledrag table.
 */
function kalagraphs_preprocess_inline_entity_form_entity_table(&$variables) {
  $bundles = [];
  $kalaponent_types = [];
  foreach (Element::children($variables['form']) as $i) {
    // Get the bundle name of each ¶.
    $entity = $variables['form'][$i]['#entity'];
    $bundle = $entity->bundle();
    $bundles[$i] = $bundle;

    if ($bundle == 'kalagraphs_component') {
      // This is a kalagraph component so we want to store the type.
      $kalaponent_types[$i] = $entity->get('field_kalagraphs_type')->getString();
    }
  }

  foreach ($variables['table']['#rows'] as $i => &$row) {
    // When coming in from ajax there is an extra row for the entity form.
    if (isset($bundles[$i])) {
      // Add the bundle name as a class on it's row for exceptional styling
      // radness.
      $row['class'][] = Html::getClass($bundles[$i]);

      if ($bundles[$i] == 'kalagraphs_region') {
        $variables['table']['#rows'][$i - 1]['class'][] = 'kalagraphs-region-end';
      }

      // Remove redundant type labels and set the component labels to their
      // kalagraph type.
      $component_label = &$row['data'][3]['data'][0]['#plain_text'];
      if (isset($kalaponent_types[$i])) {
        $info = KALAGRAPHS_TYPES[$kalaponent_types[$i]];
        $new_label = $info['title'];
        $component_label = $new_label;
      }
      else {
        $component_label = '';
      }

      // Add a title to the layout type.
      if ($bundles[$i] == 'layout' && is_array($row['data'][2])) {
        $layout_dropdown = $row['data'][2]['data'];
        $markup = '<h3>Layout:</h3>' . $layout_dropdown;
        $row['data'][2]['data'] = Drupal\Core\Render\Markup::create($markup);
      }
    }
  }
}
