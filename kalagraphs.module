<?php

/**
 * @file
 * Contains kalagraphs.module.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Field\FieldStorageDefinitionInterface;
use Drupal\Core\Entity\FieldableEntityInterface;
use Drupal\Core\Render\Element;
use Drupal\Core\Form\FormStateInterface;
use Drupal\paragraphs\Entity\Paragraph;
use Drupal\Component\Utility\Html;

/**
 * Implements hook_help().
 */
function kalagraphs_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    case 'help.page.kalagraphs':
      $output = '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Kalagraphs provides a flexible Paragraph type called &quot;Component&quot; that allows editors to choose with which Twig template the component will render.') . '</p>';
      return $output;
  }
}

/**
 * Implements hook_theme().
 */
function kalagraphs_theme() {
  return [

    // Instantiate a master theme hook that calls the styleguide templates.
    'paragraph__kalagraphs_component__default' => [
      'base hook' => 'paragraph',
    ],

    // Create a theme hook to hide paragraphs.
    'kalagraphs_hidden' => [
      'function' => '_kalagraphs_render_hidden',
    ],

    // Add a field template to relieve some divitus.
    'kalagraphs_field' => [
      'base hook' => 'field',
    ],
  ];
}

/**
 * Theme callback to render the "hidden" component type.
 */
function _kalagraphs_render_hidden() {
  // Don't render anything.
}

/**
 * Preprocessor for the "paragraphs__kalagraphs_component__default" theme hook.
 *
 * Populates template data with field items, using template-friendly variable
 * names.
 */
function template_preprocess_paragraph__kalagraphs_component__default(&$vars) {

  // Provide the component's template name for inclusion by the master template.
  $paragraph = $vars['paragraph'];
  $type = $paragraph->field_kalagraphs_type->value;
  $info = KALAGRAPHS_TYPES[$type];
  if (isset($info['path'])) {
    $path = $info['path'];
    $template = isset($info['template']) ? $info['template'] : $type;
    $vars['component'] = "$path/$template/$template.html.twig";
  }

  // Add a flag to indicate it is rendering in a Drupal context.
  // @todo This doesn't cover non-Paragraph theme hooks, e.g., atom components
  // used for some fields.
  $vars['drupal'] = TRUE;

  // Insert the author's name and "created" (aka "Authored on") date from the
  // entity to which this paragraph belongs.
  $parent = $paragraph->getParentEntity();
  $author = empty($parent) ? \Drupal::currentUser() : $parent->getOwner();
  $vars['author'] = $author->getDisplayName();
  $timestamp = empty($parent) ? time() : $parent->getCreatedTime();
  $vars['date'] = date('m/d/Y - h:i A', $timestamp);

  // Map field items to template variables.
  $elements = &$vars['elements'];
  foreach (Element::children($elements) as $field) {

    // Make a template-friendly variable name by stripping "field_kalagraphs_"
    // from the front.
    $name = substr($field, 17);
    $element = &$elements[$field];
    foreach (Element::children($element) as $item) {

      // Send the field item's render array to Twig.
      switch ($name) {

        // Extract the longtext field's "summary" subfield.
        case 'text':
          if (!empty($element['#items'][$item]->summary)) {
            $vars['subtitle'] = $element['#items'][$item]->summary;
          }

        default:
          $vars[$name][] = $element[$item];
      }
    }
  }

  // Provide a unique id attribute for the element that may or may not get used.
  $vars['id'] = Html::getUniqueId("kalagraphs-component-$type");
}

/**
 * Implements hook_theme_suggestions_HOOK_alter() for paragraph().
 *
 * Adds support for per-component-type theme hooks.
 */
function kalagraphs_theme_suggestions_paragraph_alter(array &$suggestions, array $vars) {
  $paragraph = $vars['elements']['#paragraph'];
  $bundle    = $paragraph->bundle();
  if (substr($bundle, 0, 11) === 'kalagraphs_') {
    $view_mode = $vars['elements']['#view_mode'];
    if ('default' === $view_mode) {
      $type = $paragraph->field_kalagraphs_type->value;
      $suggestions[] = "kalagraphs_$type";
    }
  }
}

/**
 * Implements hook_theme_suggestions_HOOK_alter() for field().
 *
 * Renders Kalagraphs fields with a minimal template. Note that this only gets
 * invoked when a Kalagraphs type doesn't map to a custom template or render
 * function and therefore gets displayed through the regular field pipeline.
 */
function kalagraphs_theme_suggestions_field_alter(array &$suggestions, array $vars) {
  $field = $vars['element']['#field_name'];
  if (strpos($field, 'field_kalagraphs_') === 0) {
    $view_mode = $vars['element']['#view_mode'];
    if ('default' === $view_mode) {
      $suggestions[] = 'kalagraphs_field';
    }
  }
}

/**
 * Implements callback_allowed_values_function().
 *
 * Returns the allowed values for the "Kalagraphs Type" options list field.
 */
function _kalagraphs_options(FieldStorageDefinitionInterface $definition, FieldableEntityInterface $entity = NULL, &$cacheable = TRUE) {
  $keys = array_keys(KALAGRAPHS_TYPES);
  $values = array_column(KALAGRAPHS_TYPES, 'title');
  $options = array_combine($keys, $values);
  asort($options);
  $options['hidden'] = 'Hidden';
  return $options;
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter() for entity_reference_paragraphs().
 *
 * Modifies the "Default" Paragraphs field widget.
 */
function kalagraphs_field_widget_entity_reference_paragraphs_form_alter(&$element, FormStateInterface $form_state, $context) {
  _kalagraphs_process_form($element, $form_state, $context);
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter() for paragraphs().
 *
 * Modfies the "Experimental" (as of now) Paragraphs field widget.
 */
function kalagraphs_field_widget_paragraphs_form_alter(&$element, FormStateInterface $form_state, $context) {
  _kalagraphs_process_form($element, $form_state, $context);
}

/**
 * Adds conditional display and other sauce to the Paragaphs edit form.
 *
 * For paramter info, see hook_field_widget_WIDGET_TYPE_form_alter().
 */
function _kalagraphs_process_form(&$element, FormStateInterface $form_state, $context) {

  // Only run for Kalagraphs paragraphs.
  if (!_kalagraphs_element_is_kalagraph($element, $form_state, $context)) {
    return;
  }

  // Only run once a Paragraph form has been loaded.
  $subform = &$element['subform'];
  $fields = Element::children($subform);
  if (!count($fields)) {
    return;
  }

  // Filter options list to the appropriate layer (top-level or sub-component).
  $field = $context['items']->getName();
  $is_subcomponent = 'field_kalagraphs_subcomponents' === $field;
  $options = &$subform['field_kalagraphs_type']['widget']['#options'];
  foreach (KALAGRAPHS_TYPES as $type => $info) {
    // If the component does not specify "is_subcomponent", just always show it.
    if (isset($info['is_subcomponent']) &&
        $info['is_subcomponent'] !== $is_subcomponent) {
      unset($options[$type]);
    }
  }

  // Use the form's #parents to determine the States API selector.
  $parents_array = $subform['#parents'];
  $first_parent = array_shift($parents_array);
  $parents = $first_parent . '[' . implode('][', $parents_array) . ']';
  $selector = ":input[name='{$parents}[field_kalagraphs_type]']";

  // Add helptext for when no component type is yet selected.
  $help = &$subform['help']['_none'];
  $help['#type'] = 'item';
  $help['#title'] = t('Choose a component type to create.');
  $help['#states']['visible'][$selector][] = ['value' => '_none'];

  // Add a null state so fields not used on any component type are still hidden.
  foreach ($fields as $field) {
    // Don't hide the "Display as" selector.
    if ('field_kalagraphs_type' !== $field) {
      $subform[$field]['#states']['visible'][$selector][] = ['value' => -1];
    }
  }

  // Add helptext and conditional states for each field type.
  foreach (KALAGRAPHS_TYPES as $type => $info) {
    $condition = ['value' => $type];

    // Add helptext for each component type.
    if (!empty($info['help'])) {
      $help = &$subform['help'][$type];
      $help['#type'] = 'item';
      $help['#title'] = $info['help'];
      $help['#states']['visible'][$selector][] = $condition;
    }

    // Only show the fields appropriate for the component type.
    foreach ($info['fields'] as $field) {
      if (isset($subform["field_kalagraphs_$field"])) {
        $subform["field_kalagraphs_$field"]['#states']['visible'][$selector][]
          = $condition;
      }
    }
  }
}

/**
 * Determines whether to proceed with processing of the Paragraphs field widget.
 *
 * For parameter info, see hook_field_widget_WIDGET_TYPE_form_alter().
 */
function _kalagraphs_element_is_kalagraph(&$element, FormStateInterface $form_state, $context) {

  // For previously-saved items, the entity (and therefore bundle) is available.
  $delta = $element['#delta'];

  if (isset($context['items'][$delta]->target_id)) {
    $id = $context['items'][$delta]->target_id;
    $bundle = Paragraph::load($id)->bundle();
    return strpos($bundle, 'kalagraphs_') === 0;
  }

  // For newly-added paragraphs, there is no entity yet, so we use the form's
  // "triggering element" to identify which "Add Paragraph" button was pushed
  // (i.e., the bundle of the new item). However, this only tells us about the
  // item being added right now and nothing about the items previously-added in
  // this session. To get around this, we use a flag to indicate whether each
  // unsaved item has already been verified as being a Kalagraphs bundle.
  //
  // Initialise a container to hold flag data for the lifetime of the form.
  $kalagraphs_bundle_check = $form_state->has(__FUNCTION__)
    ? $form_state->get(__FUNCTION__) : [];

  // Get a reference to the result (whether the item is a Kalagraphs bundle).
  $is_kalagraph = &$kalagraphs_bundle_check[$delta];

  // Has this item already been processed?
  if (isset($is_kalagraph)) {
    return $is_kalagraph;
  }

  // This item has not been processed, so it was just created or deleted.
  // If just created, the button should have an associated bundle.
  $button = $form_state->getTriggeringElement();
  if (isset($button['#bundle_machine_name'])) {
    $bundle = $button['#bundle_machine_name'];
    $is_kalagraph = strpos($bundle, 'kalagraphs_') === 0;
    $form_state->set(__FUNCTION__, $kalagraphs_bundle_check);
    return $is_kalagraph;
  }
}
